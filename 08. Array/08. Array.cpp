#include <iostream>

using namespace std;

int main()
{
    /*****************************************************************************************
     * 배열 (Array)
     *
     * 같은 자료형의 여러 변수를 연속적으로 배치하여 저장한 데이터 유형
     * 배열을 구성하는 각 변수를 요소 (element)라고 하며, 요소가 연속적으로 모여 배열을 구성함
     *****************************************************************************************/

    // <배열 선언>
    // 자료형 배열이름[배열길이];
    int array[5];                   // int 자료형의 변수 5개를 연속적으로 선언
    int numbers[3] = { 1, 3, 5 };   // int 자료형의 변수 3개를 연속적으로 선언과 초기화를 진행
    int ints[] = { 5, 7, 9, 8 };    // 배열의 길이를 지정하지 않았지만 4개를 사용함으로 4 길이의 배열을 선언


    // <인덱스 (index)>
    // 배열의 요소를 접근하기 위한 수단으로 [](하위연산자) 사이에 인덱스를 통해 요소에 접근
    // 인덱스는 0부터 시작하며, 길이가 N인 배열은 N-1까지 인덱스를 가질 수 있음
    cout << "numbers 배열의 1번째 요소는 " << numbers[0] << endl;
    cout << "numbers 배열의 3번째 요소는 " << numbers[2] << endl;


    // <배열의 길이>
    // 배열은 같은 자료형을 연속적으로 배치하는 방식이므로 전체크기 / 하나의크기 를 통해 길이를 확인가능
    // sizeof(배열이름) / sizeof(배열이름[0])
    cout << "numbers 배열의 길이는 " << sizeof(numbers) / sizeof(numbers[0]) << endl;


    // <고정 배열>
    // 배열의 길이는 컴파일시에 정해져 있어야 하며 변경할 수 없음
    // 프로그램 동작중(런타임)에 따라 달라질 수 있는 경우의 크기는 사용할 수 없음
    int array1[5];          // 사용가능

    const int LENGTH = 5;
    int array2[LENGTH];     // 사용가능

    int temp = 3;
    // int array3[temp];    // 사용불가능


    // <동적 배열>
    // 동적할당을 진행하는 경우 런타임시에 배열의 크기를 원하는만큼 할당 할 수 있음
    // 프로그램 동작중(런타임)에 따라 달라질 수 있는 경우의 크기는 사용할 수 있음
    int size = 10;
    int* array3 = new int[size];

    delete[] array3;


    // <배열 사용시 주의사항>
    // 배열의 길이를 벗어나는 인덱스 사용시 의도하지 않은 메모리 위치를 변경할 수 있음
    // 반드시 배열을 사용시 배열의 길이를 벗어나지 않는 인덱스 사용을 진행해야 함
    // array[-1] = 20;      // 주의! 프로그램을 손상시킬 수 있음
    // array[6] = 10;


    // <다차원 배열>
    // 배열의 요소로 배열을 저장하도록 하여 여러 차원을 가진 배열처럼 사용할 수 있음
    int maxtrix[3][4];      // int 자료형의 변수를 4개를 가진 배열을 3개 만들어 12개의 int를 가진 2차원 배열 선언
    /*
    [0][0]  [0][1]  [0][2]  [0][3]
    [1][0]  [1][1]  [1][2]  [1][3]
    [2][0]  [2][1]  [2][2]  [2][3]
    */
    int table[3][2] = { {0, 1}, {2, 3}, {4, 5} };   // 이차원 배열의 초기화
    int cube[2][3][4];      // 2 * 3 * 4 = 24, int 자료형의 변수를 총 24개 가진 3차원 배열


    // <배열과 반복>
    // 배열의 인덱스를 반복하여 증가시키며 사용하는 경우 배열의 모든 요소를 반복 수행하는데 용이함
    int scores[] = { 84, 92, 76, 81, 56 };
    int length = sizeof(scores) / sizeof(scores[0]);
    int sum = 0;
    for (int i = 0; i < length; i++)
    {
        sum += scores[i];
    }


    /****************************************************************************************
     * 배열과 포인터
     *
     * 같은 자료형을 연속적으로 배치하는 배열의 특징에 의해 C++에서 배열은 포인터를 통해 관리함
     * 배열이 많은 배열 요소를 가지고 있어도 포인터를 활용하면 특정 요소에 빠른 접근이 가능
     ****************************************************************************************/

    // <포인터 산술연산>
    // 포인터에 산술연산(+-)을 진행하는 경우 컴파일러는 자료형의 크기만큼 곱하여 연산을 진행
    int iValue = 0;
    int* intPtr = &iValue;
    cout << "int 포인터 변수의 주소값 " << intPtr << endl;
    cout << "int 포인터 변수에 -1을 진행하는 경우 " << intPtr - 1 << endl;
    cout << "int 포인터 변수에 +1을 진행하는 경우 " << intPtr + 1 << endl;

    double dValue = 0;
    double* doublePtr = &dValue;
    cout << "double 포인터 변수의 주소값 " << doublePtr << endl;
    cout << "double 포인터 변수에 -1을 진행하는 경우 " << doublePtr - 1 << endl;
    cout << "double 포인터 변수에 +1을 진행하는 경우 " << doublePtr + 1 << endl;


    // <배열이름과 주소값>
    // C++에서 배열의 이름은 배열의 시작주소를 표현
    cout << "array 배열의 첫번째 요소의 주소는 " << &array[0] << endl;
    cout << "array 배열의 이름에 보관된 데이터는 " << array << endl;


    // <배열의 구현 원리>
    // 배열은 모든 요소의 데이터를 관리하는 방식이 아닌 시작주소를 통해 요소가 저장된 위치를 특정하여 접근하는 방식을 사용
    // 배열 요소의 주소는 시작주소 + 인덱스 * 자료형의크기 를 통하여 확인할 수 있음
    // 배열이름[인덱스] 는 *(배열이름 + 인덱스) 으로 변환되어 처리됨
    cout << "array 배열의 첫번째 요소의 주소 " << &array[0] << " , " << array + 0 << endl;
    cout << "array 배열의 두번째 요소의 주소 " << &array[1] << " , " << array + 1 << endl;
    cout << "array 배열의 세번째 요소의 주소 " << &array[2] << " , " << array + 2 << endl;

    cout << "array 배열의 첫번째 요소의 값 " << array[0] << " , " << *(array + 0) << endl;
    cout << "array 배열의 두번째 요소의 값 " << array[1] << " , " << *(array + 1) << endl;
    cout << "array 배열의 세번째 요소의 값 " << array[2] << " , " << *(array + 2) << endl;


    // <포인터 변수를 통한 배열 참조>
    // 배열은 포인터 변수를 이용하여 모든 동작이 가능
    const int* ptr = array;
    cout << "포인터 변수를 통한 배열 요소 확인 " << ptr[0] << endl;
}
